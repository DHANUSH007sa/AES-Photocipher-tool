from Cryptodome.Cipher import AES\nfrom Cryptodome.Util.Padding import pad, unpad\nfrom Cryptodome.Random import get_random_bytes\nfrom Cryptodome.Protocol.KDF import PBKDF2\nfrom PIL import Image\nimport os\nimport hashlib\nimport io\n\nclass ImageEncryptor:\n    SALT = b'AES_PHOTOCIPHER_SALT_2024'\n    ITERATIONS = 1000000\n    MIN_PASSWORD_LENGTH = 8\n\n    @staticmethod\n    def _derive_key(password):\n        if not isinstance(password, str):\n            raise TypeError("Password must be a string")\n        if len(password) < ImageEncryptor.MIN_PASSWORD_LENGTH:\n            raise ValueError(f"Password must be at least {ImageEncryptor.MIN_PASSWORD_LENGTH} characters long.")\n        key = PBKDF2(password, ImageEncryptor.SALT, dkLen=32, count=ImageEncryptor.ITERATIONS, hmac_hash_module=hashlib.sha256)\n        return key\n\n    @staticmethod\n    def encrypt_image(file_path, password):\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"File not found: {file_path}")\n        if not isinstance(password, str):\n            raise TypeError("Password must be a string")\n        if len(password) < ImageEncryptor.MIN_PASSWORD_LENGTH:\n            raise ValueError(f"Password must be at least {ImageEncryptor.MIN_PASSWORD_LENGTH} characters long.")\n        try:\n            img = Image.open(file_path)\n            supported_formats = ["PNG", "JPEG", "JPG", "BMP", "GIF"]\n            if img.format and img.format.upper() not in supported_formats:\n                raise ValueError(f"Unsupported image format: {img.format}.")\n            with open(file_path, 'rb') as f:\n                image_data = f.read()\n            if len(image_data) == 0:\n                raise ValueError("Image file is empty")\n            key = ImageEncryptor._derive_key(password)\n            iv = get_random_bytes(16)\n            cipher = AES.new(key, AES.MODE_CBC, iv)\n            padded_data = pad(image_data, AES.block_size)\n            encrypted_data = cipher.encrypt(padded_data)\n            with open(file_path, 'wb') as f:\n                f.write(iv)\n                f.write(encrypted_data)\n        except Exception as e:\n            raise Exception(f"Encryption failed: {str(e)}")\n\n    @staticmethod\n    def decrypt_image(file_path, password):\n        if not os.path.exists(file_path):\n            raise FileNotFoundError(f"File not found: {file_path}")\n        try:\n            with open(file_path, 'rb') as f:\n                iv = f.read(16)\n                encrypted_data = f.read()\n            if len(iv) != 16:\n                raise ValueError("Invalid encrypted file: missing or corrupted IV")\n            if len(encrypted_data) == 0:\n                raise ValueError("Invalid encrypted file: no encrypted data found")\n            key = ImageEncryptor._derive_key(password)\n            cipher = AES.new(key, AES.MODE_CBC, iv)\n            try:\n                padded_data = cipher.decrypt(encrypted_data)\n                decrypted_data = unpad(padded_data, AES.block_size)\n            except ValueError as e:\n                raise ValueError("Decryption failed: Invalid password or corrupted file.")\n            try:\n                Image.open(io.BytesIO(decrypted_data))\n            except Exception as e:\n                raise ValueError(f"Decrypted data is not a valid image: {str(e)}")\n            with open(file_path, 'wb') as f:\n                f.write(decrypted_data)\n        except ValueError:\n            raise\n        except Exception as e:\n            raise Exception(f"Decryption failed: {str(e)}")